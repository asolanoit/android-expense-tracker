package com.antso.expensesmanager.accounts;

import android.content.Context;
import android.util.Log;

import com.antso.expensesmanager.entities.Account;
import com.antso.expensesmanager.entities.Transaction;
import com.antso.expensesmanager.enums.TransactionDirection;
import com.antso.expensesmanager.enums.TransactionType;
import com.antso.expensesmanager.persistence.DatabaseHelper;

import org.joda.time.DateTime;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public enum AccountManager {
        ACCOUNT_MANAGER;

    public class AccountInfo {
        public Collection<Transaction> transactions;
        public Account account;

        public BigDecimal balance;
        public BigDecimal monthIn;
        public BigDecimal monthOut;
        public BigDecimal monthBalance;
    }
    private Map<String, AccountInfo> accounts;
    private DatabaseHelper dbHelper = null;


    private AccountManager() {
        accounts = new HashMap<String, AccountInfo>();
    }

    public void start(Context context) {
        if (dbHelper == null) {
            dbHelper = new DatabaseHelper(context);

            Collection<Account> accounts = dbHelper.getAccounts();
            for (Account account : accounts) {
                ACCOUNT_MANAGER.addAccount(account, dbHelper.getTransactionsByAccount(account.getId()));
            }
        }
    }

    public void stop() {
        if (dbHelper != null) {
            dbHelper.close();
            dbHelper = null;
        }
    }

    private void addAccount(Account account, Collection<Transaction> transactions) {
        AccountInfo accountInfo = new AccountInfo();
        accountInfo.account = account;

        accountInfo.transactions = new ArrayList<Transaction>(transactions.size());
        for (Transaction transaction : transactions) {
            accountInfo.transactions.add(transaction);
            if (transaction.getType().equals(TransactionType.Recurrent) &&
                    !transaction.isAutoGenerated()) {
                explodeRecurrentTransaction(accountInfo, transaction, DateTime.now());
            }
        }

        accountInfo.balance = BigDecimal.ZERO;
        accountInfo.monthOut = BigDecimal.ZERO;
        accountInfo.monthIn = BigDecimal.ZERO;
        accountInfo.monthBalance = BigDecimal.ZERO;

        refresh(accountInfo, DateTime.now());
        accounts.put(account.getId(), accountInfo);
    }

    public void insertAccount(Account account) {
        dbHelper.insertAccount(account);
        addAccount(account, dbHelper.getTransactionsByAccount(account.getId()));
    }

    public void removeAccount(Account account) {
        accounts.remove(account.getId());
        dbHelper.deleteAccount(account.getId());
    }

    private void refresh(AccountInfo accountInfo, DateTime currentDate) {
        for (Transaction transaction : accountInfo.transactions) {
            switch (transaction.getType()) {
                case Single:
                case Transfer:
                case Recurrent:
                    refreshSingleTransaction(accountInfo, transaction, currentDate);
                    break;
                case Undef:
                    break;
            }
        }
    }

    private void explodeRecurrentTransaction(AccountInfo accountInfo, Transaction transaction,
                                             DateTime currentDate) {
        //TODO support transaction with repetition num instead of end-date and viceversa
        int iterationNum = 1;
        DateTime newDate = getNextTransactionDate(transaction, iterationNum);

        while (newDate.isBefore(transaction.getEndDate()) && newDate.isBefore(currentDate)) {
            accountInfo.transactions.add(createRecurrentCopy(transaction, newDate));
            iterationNum++;
            newDate = getNextTransactionDate(transaction, iterationNum);
        }
    }

    private DateTime getNextTransactionDate(Transaction transaction, int step) {
        DateTime start = transaction.getDateTime();
        switch (transaction.getFrequencyUnit()) {
            case Daily:
                return start.plusDays(transaction.getFrequency() * step);
            case Weekly:
                return  start.plusWeeks(transaction.getFrequency() * step);
            case Monthly:
                return start.plusMonths(transaction.getFrequency() * step);
            case Yearly:
                return  start.plusYears(transaction.getFrequency() * step);
        }
        return null;
    }

    private Transaction createRecurrentCopy(Transaction transaction, DateTime date) {
        Transaction t = new Transaction(transaction.getId(),
            transaction.getDescription(),
            transaction.getDirection(),
            transaction.getType(),
            transaction.getAccountId(),
            transaction.getBudgetId(),
            transaction.getValue(),
            date);

        t.setLinkedTransactionId(transaction.getLinkedTransactionId());
        t.setAutoGenerated(true);
        return t;
    }

    private void refreshSingleTransaction(AccountInfo accountInfo, Transaction transaction,
                                          DateTime currentDate) {
        int currentMonth = currentDate.getMonthOfYear();
        int currentYear = currentDate.getYear();

        if (transaction.getDirection().equals(TransactionDirection.Out)) {
            accountInfo.balance = accountInfo.balance.subtract(transaction.getValue());

            if(currentMonth == transaction.getDateTime().getMonthOfYear() &&
                    currentYear == transaction.getDateTime().getYear()) {
                accountInfo.monthBalance = accountInfo.monthBalance.subtract(transaction.getValue());
                accountInfo.monthOut = accountInfo.monthOut.add(transaction.getValue());
            }
        }
        if (transaction.getDirection().equals(TransactionDirection.In)) {
            accountInfo.balance = accountInfo.balance.add(transaction.getValue());

            if(currentMonth == transaction.getDateTime().getMonthOfYear() &&
                    currentYear == transaction.getDateTime().getYear()) {
                accountInfo.monthBalance = accountInfo.monthBalance.add(transaction.getValue());
                accountInfo.monthIn = accountInfo.monthIn.add(transaction.getValue());
            }
        }

    }

    public List<AccountInfo> getAccountInfo() {
        List<AccountInfo> accountInfoList = new ArrayList<AccountInfo>(accounts.size());
        for(AccountInfo info : accounts.values()) {
            accountInfoList.add(info);
        }
        return accountInfoList;
    }

    public AccountInfo getAccountInfo(String accountId) {
        return accounts.get(accountId);
    }

    public Map<String, Account> getAccountsByName() {
        Map<String, Account> accountByName = new HashMap<String, Account>(accounts.size());
        for(AccountInfo info : accounts.values()) {
            if(!accountByName.containsKey(info.account.getName())) {
                accountByName.put(info.account.getName(), info.account);
            } else {
                Log. i("AccountManager", "Error creating accountByName map: Account with this name already added {Name " + info.account.getName() + "}");
            }
        }
        return accountByName;
    }

    public Collection<Account> getAccounts() {
        return dbHelper.getAccounts();
    }

}
