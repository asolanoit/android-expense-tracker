package com.antso.expensesmanager.accounts;

import android.util.Log;

import com.antso.expensesmanager.entities.Account;
import com.antso.expensesmanager.entities.Transaction;
import com.antso.expensesmanager.enums.TransactionDirection;
import com.antso.expensesmanager.enums.TransactionType;

import org.joda.time.DateTime;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public enum AccountManager {
        ACCOUNT_MANAGER;

    public class AccountInfo {
        public Collection<Transaction> transactions;
        public Account account;

        public BigDecimal balance;
        public BigDecimal monthIn;
        public BigDecimal monthOut;
        public BigDecimal monthBalance;
    }
    private Map<String, AccountInfo> accounts;


    private AccountManager() {
        accounts = new HashMap<String, AccountInfo>();
    }

    public void addAccount(Account account, Collection<Transaction> transactions) {
        AccountInfo accountInfo = new AccountInfo();
        accountInfo.account = account;

        accountInfo.transactions = new ArrayList<Transaction>(transactions.size());
        for (Transaction transaction : transactions) {
            accountInfo.transactions.add(transaction);
            if (transaction.getType().equals(TransactionType.Recurrent) &&
                    !transaction.isAutoGenerated()) {
                explodeRecurrentTransaction(accountInfo, transaction,
                        DateTime.now().getDayOfMonth(),
                        DateTime.now().getMonthOfYear(),
                        DateTime.now().getYear());
            }
        }

        accountInfo.balance = BigDecimal.ZERO;
        accountInfo.monthOut = BigDecimal.ZERO;
        accountInfo.monthIn = BigDecimal.ZERO;
        accountInfo.monthBalance = BigDecimal.ZERO;

        refresh(accountInfo, DateTime.now().getMonthOfYear(), DateTime.now().getYear());
        accounts.put(account.getId(), accountInfo);
    }

    public void removeAccount(Account account) {
        accounts.remove(account.getId());
    }

    public void refresh(AccountInfo accountInfo, int currentMonth, int currentYear) {
        for (Transaction transaction : accountInfo.transactions) {
            switch (transaction.getType()) {
                case Single:
                case Transfer:
                case Recurrent:
                    refreshSingleTransaction(accountInfo, transaction, currentMonth, currentYear);
                    break;
                case Undef:
                    break;
            }
        }
    }

    private void explodeRecurrentTransaction(AccountInfo accountInfo, Transaction transaction,
                                             int currentDay, int currentMonth, int currentYear) {
        //TODO support transaction with repetition num instead of end-date and viceversa

        DateTime start = transaction.getDateTime();
        DateTime currentDate = new DateTime(currentYear, currentMonth, currentDay, 0, 0);
        int iterationNum = 1;
        DateTime newDate = start;
        while (newDate.isBefore(transaction.getEndDate()) && newDate.isBefore(currentDate)) {
            switch (transaction.getFrequencyUnit()) {
                case Daily:
                    newDate = start.plusDays(transaction.getFrequency() * iterationNum);
                    break;
                case Weekly:
                    newDate = start.plusWeeks(transaction.getFrequency() * iterationNum);
                    break;
                case Monthly:
                    newDate = start.plusMonths(transaction.getFrequency() * iterationNum);
                    break;
                case Yearly:
                    newDate = start.plusYears(transaction.getFrequency() * iterationNum);
                    break;
            }

            accountInfo.transactions.add(createRecurrentCopy(transaction, newDate));
            iterationNum++;
        }
    }

    private Transaction createRecurrentCopy(Transaction transaction, DateTime date) {
        Transaction t = new Transaction(transaction.getId(),
            transaction.getDescription(),
            transaction.getDirection(),
            transaction.getType(),
            transaction.getAccountId(),
            transaction.getBudgetId(),
            transaction.getValue(),
            date);

        t.setLinkedTransactionId(transaction.getLinkedTransactionId());
        t.setAutoGenerated(true);
        return t;
    }

    private void refreshSingleTransaction(AccountInfo accountInfo, Transaction transaction,
                                          int currentMonth, int currentYear) {
        if (transaction.getDirection().equals(TransactionDirection.Out)) {
            accountInfo.balance = accountInfo.balance.subtract(transaction.getValue());

            if(currentMonth == transaction.getDateTime().getMonthOfYear() &&
                    currentYear == transaction.getDateTime().getYear()) {
                accountInfo.monthBalance = accountInfo.monthBalance.subtract(transaction.getValue());
                accountInfo.monthOut = accountInfo.monthOut.add(transaction.getValue());
            }
        }
        if (transaction.getDirection().equals(TransactionDirection.In)) {
            accountInfo.balance = accountInfo.balance.add(transaction.getValue());

            if(currentMonth == transaction.getDateTime().getMonthOfYear() &&
                    currentYear == transaction.getDateTime().getYear()) {
                accountInfo.monthBalance = accountInfo.monthBalance.add(transaction.getValue());
                accountInfo.monthIn = accountInfo.monthOut.add(transaction.getValue());
            }
        }

    }

    public List<AccountInfo> getAccountInfo() {
        List<AccountInfo> accountInfoList = new ArrayList<AccountInfo>(accounts.size());
        for(AccountInfo info : accounts.values()) {
            accountInfoList.add(info);
        }
        return accountInfoList;
    }

    public AccountInfo getAccountInfo(String accountId) {
        return accounts.get(accountId);
    }

    public Map<String, Account> getAccountsByName() {
        Map<String, Account> accountByName = new HashMap<String, Account>(accounts.size());
        for(AccountInfo info : accounts.values()) {
            if(!accountByName.containsKey(info.account.getName())) {
                accountByName.put(info.account.getName(), info.account);
            } else {
                Log. i("AccountManager", "Error creating accountByName map: Account with this name already added {Name " + info.account.getName() + "}");
            }
        }
        return accountByName;
    }

}
