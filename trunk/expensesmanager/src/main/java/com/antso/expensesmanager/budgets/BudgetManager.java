package com.antso.expensesmanager.budgets;

import android.content.Context;
import android.util.Log;

import com.antso.expensesmanager.accounts.AccountManager;
import com.antso.expensesmanager.entities.Account;
import com.antso.expensesmanager.entities.Budget;
import com.antso.expensesmanager.entities.Transaction;
import com.antso.expensesmanager.enums.BudgetPeriodUnit;
import com.antso.expensesmanager.enums.TransactionDirection;
import com.antso.expensesmanager.persistence.DatabaseHelper;

import org.joda.time.DateTime;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public enum BudgetManager {
        BUDGET_MANAGER;

    public class BudgetInfo {
        public Collection<Transaction> transactions;
        public Budget budget;

        public BigDecimal periodIn;
        public BigDecimal periodOut;
        public BigDecimal periodBalance;
    }
    private Map<String, BudgetInfo> budgets;
    private DatabaseHelper dbHelper = null;

    private BudgetManager() {
        budgets = new HashMap<String, BudgetInfo>();
    }

    public void start(Context context) {
        if (dbHelper == null) {
            dbHelper = new DatabaseHelper(context);

            Collection<Budget> budgets = dbHelper.getBudgets();
            for (Budget budget : budgets) {
                BudgetManager.BUDGET_MANAGER
                        .addBudget(budget, dbHelper.getTransactionsByBudget(budget.getId()));
            }
        }
    }


    public void stop() {
        if (dbHelper != null) {
            dbHelper.close();
            dbHelper = null;
        }
    }

    private void addBudget(Budget budget, Collection<Transaction> transactions) {
        BudgetInfo budgetInfo = new BudgetInfo();
        budgetInfo.budget = budget;

        budgetInfo.transactions = new ArrayList<Transaction>(transactions.size());
        for (Transaction transaction : transactions) {
            budgetInfo.transactions.add(transaction);
//            if (transaction.getType().equals(TransactionType.Recurrent) &&
//                    !transaction.isAutoGenerated()) {
//                explodeRecurrentTransaction(budgetInfo, transaction,
//                        DateTime.now().getDayOfMonth(),
//                        DateTime.now().getMonthOfYear(),
//                        DateTime.now().getYear());
//            }
        }

        budgetInfo.periodIn = BigDecimal.ZERO;
        budgetInfo.periodOut = BigDecimal.ZERO;
        budgetInfo.periodBalance = BigDecimal.ZERO;

        refresh(budgetInfo, DateTime.now());
        budgets.put(budget.getId(), budgetInfo);
    }

    public void insertBudget(Budget budget) {
        dbHelper.insertBudget(budget);
        addBudget(budget, dbHelper.getTransactionsByBudget(budget.getId()));
    }

    public void removeBudget(Budget budget) {
        budgets.remove(budget.getId());
        dbHelper.deleteBudget(budget.getId());
    }

    public void refresh(BudgetInfo budgetInfo, DateTime currentDateTime) {
        for (Transaction transaction : budgetInfo.transactions) {
            switch (transaction.getType()) {
                case Single:
                case Transfer:
                case Recurrent:
                    refreshSingleTransaction(budgetInfo, transaction, currentDateTime);
                    break;
                case Undef:
                    break;
            }
        }
    }

//    private void explodeRecurrentTransaction(AccountInfo accountInfo, Transaction transaction,
//                                             int currentDay, int currentMonth, int currentYear) {
//        //TODO support transaction with repetition num instead of end-date and viceversa
//
//        DateTime start = transaction.getDateTime();
//        DateTime currentDate = new DateTime(currentYear, currentMonth, currentDay, 0, 0);
//        int iterationNum = 1;
//        DateTime newDate = start;
//        while (newDate.isBefore(transaction.getEndDate()) && newDate.isBefore(currentDate)) {
//            switch (transaction.getFrequencyUnit()) {
//                case Daily:
//                    newDate = start.plusDays(transaction.getFrequency() * iterationNum);
//                    break;
//                case Weekly:
//                    newDate = start.plusWeeks(transaction.getFrequency() * iterationNum);
//                    break;
//                case Monthly:
//                    newDate = start.plusMonths(transaction.getFrequency() * iterationNum);
//                    break;
//                case Yearly:
//                    newDate = start.plusYears(transaction.getFrequency() * iterationNum);
//                    break;
//            }
//
//            accountInfo.transactions.add(createRecurrentCopy(transaction, newDate));
//            iterationNum++;
//        }
//    }
//
//    private Transaction createRecurrentCopy(Transaction transaction, DateTime date) {
//        Transaction t = new Transaction(transaction.getId(),
//            transaction.getDescription(),
//            transaction.getDirection(),
//            transaction.getType(),
//            transaction.getAccountId(),
//            transaction.getBudgetId(),
//            transaction.getValue(),
//            date);
//
//        t.setLinkedTransactionId(transaction.getLinkedTransactionId());
//        t.setAutoGenerated(true);
//        return t;
//    }
//
    private void refreshSingleTransaction(BudgetInfo budgetInfo, Transaction transaction,
                                          DateTime currentDateTime) {
         DateTime periodStart = getPeriodStart(budgetInfo.budget.getPeriodStart(), currentDateTime,
                budgetInfo.budget.getPeriodLength(), budgetInfo.budget.getPeriodUnit());

        if(isTransactionInPeriod(periodStart, transaction)) {
            if (transaction.getDirection().equals(TransactionDirection.Out)) {
                budgetInfo.periodBalance = budgetInfo.periodBalance.subtract(transaction.getValue());
                budgetInfo.periodOut = budgetInfo.periodOut.add(transaction.getValue());
            }
            if (transaction.getDirection().equals(TransactionDirection.In)) {
                budgetInfo.periodBalance = budgetInfo.periodBalance.add(transaction.getValue());
                budgetInfo.periodIn = budgetInfo.periodIn.add(transaction.getValue());
            }
        }
    }

    private DateTime getPeriodStart(DateTime start, DateTime currentDateTime,
                                    int periodLength, BudgetPeriodUnit periodUnit) {
        int iterationNum = 1;
        DateTime periodStart = start;
        DateTime periodStartOld = start;
        while (periodStart.isBefore(currentDateTime)) {
            periodStartOld = periodStart;
            switch (periodUnit) {
                case Day:
                    periodStart = start.plusDays(periodLength * iterationNum);
                    break;
                case Week:
                    periodStart = start.plusWeeks(periodLength * iterationNum);
                    break;
                case Month:
                    periodStart = start.plusMonths(periodLength * iterationNum);
                    break;
                case Year:
                    periodStart = start.plusYears(periodLength * iterationNum);
                    break;
            }
            iterationNum++;
        }

        return  periodStartOld;
    }

    private boolean isTransactionInPeriod(DateTime start, Transaction transaction) {
        return transaction.getDateTime().isAfter(start);
    }

    public List<BudgetInfo> getBudgetInfo() {
        List<BudgetInfo> budgetInfoList = new ArrayList<BudgetInfo>(budgets.size());
        for(BudgetInfo info : budgets.values()) {
            budgetInfoList.add(info);
        }
        return budgetInfoList;
    }

    public BudgetInfo getBudgetInfo(String budgetId) {
        return budgets.get(budgetId);
    }

    public Map<String, Budget> getBudgetsByName() {
        Map<String, Budget> budgetByName = new HashMap<String, Budget>(budgets.size());
        for(BudgetInfo info : budgets.values()) {
            if(!budgetByName.containsKey(info.budget.getName())) {
                budgetByName.put(info.budget.getName(), info.budget);
            } else {
                Log. i("BudgetManager", "Error creating budgetByName map: Budget with this name already added {Name " + info.budget.getName() + "}");
            }
        }
        return budgetByName;
    }

    public Collection<Budget> getBudgets() {
        return dbHelper.getBudgets();
    }

}
